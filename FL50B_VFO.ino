// ==============================================================================================
// Contents of this file
// ==============================================================================================

/*
The contents of this file are grouped as follows:

Introduction
  Version History
  About this program
  Acknowledgements
  Hardware Connections
Coding Standards
Global declarations and initialisations
Setup()
Loop()
Functions


// ==============================================================================================
// Introduction
// ==============================================================================================

Version history
---------------
V1.0, 11/10/2022 - First version.  
V1.0 04, 21/11/2022   Included push button debounce code written by Ben Rawlings.
V1.0 05, 09/12/2022   Minor changes.  Known issue: Requires separate EEPROM initialisation script.

About this program
------------------
This program has been developed for the Arduino Nano by Steve Rawlings, G4ALG.   

The program controls a Si5351 Direct Digital Synthesis (DDS) integrated circuit and a type 1602 
Liquid Crystal Display (LCD) to provide variable frequency oscillator (VFO) facilities.  
This program is specifically intended for use with the FL-50B transmitter, a valved transmitter 
made by Yaesu of Japan in the late 1960s and early 1970s.

The FL-50B transmitter operates on the 10, 15, 20, 40 and 80 metre amateur bands.  The original design 
allowed for use of fixed frequency (quartz crystal) operation, with the option of using an external VFO 
to control the transmit frequency.   The transmitter uses a single conversion architecture with a 5 MHz
intermediate frequency.  As result, and external VFO needs to provide a frequency range that is 
specific to each amateur band.

This program is a spin off of a much larger project.  As a result, some of the coding in this program
is redundant, and are merely artifacts of a more comprehensive VFO and transmitter control project.

This program provides no transmitter or receiver control functions.  It simply generates the desired 
VFO frequency and displays the resulting transmit frequency on a 1602 LCD display.

The FL-50B operates on five bands, these being the 10 m (28 MHz); 15 m (21 MHz); 20 m (14 MHz); 
40 m (7MHz); and 80 m (3.5 MHz) amateur bands.   'Band Up' and 'Band Down' momentary push buttons are 
used to cycle through the five bands.   Each of these five bands has a preset frequency at start-up.  
A rotary encoder is used to vary the frequency on the selected band.  A push button on the rotary 
encoder is used to select the frequency step size.  
 
The following table indicates the relationship between the FL-50B transmit frequency and the 
corresponding frequency that needs to be generated by the DDS chip:

Band      Preset Transmit Frequency            VFO Frequency           
 (m)                (MHz)                           (MHz) 
===========================================================================
 10                28.060                   Transmit Frequency - 5.1724 
 15                21.060                   Transmit Frequency - 5.1724 
 20                14.060                   Transmit Frequency - 5.1724 
 40                 7.030                   Transmit Frequency + 5.1724 
 80                 3.560                   Transmit Frequency + 5.1724


Acknowledgements
----------------
This work is largely based on a Universal VFO Controller program that was originally written 
by Paul Taylor, VK3HN (https://vk3hn.wordpress.com/).  In writing his program which targets 
Ashar Farhan VU2ESE's Arduino Nano/si5351 module ('Raduino'), Paul Taylor recognised the support 
he received from: 
QUOTE
  - Przemek Sadowski, SQ9NJE (basic controller script)
  - Jason Mildrum NT7S (si5351 library)
  - too many others to mention (ideas, code snippets).
UNQUOTE


Hardware connections
--------------------

           LCD module to Arduino Nano module Connections
           ---------------------------------------------
LCD RS (Register Select)    ____________     Arduino Nano D8 output 
                   Pin 4                     Pin 11 

          LCD E (Enable)    _____________    Arduino Nano D9 output       
                   Pin 6                     Pin 12 

                  LCD D4    _____________    Arduino Nano D10 output
                  Pin 11                     Pin 13  

                  LCD D5    _____________    Arduino Nano D11 output
                  Pin 12                     Pin 14

                  LCD D6    _____________    Arduino Nano D12 output
                  Pin 13                     Pin 15

                  LCD D7    _____________    Arduino Nano D13 output
                  Pin 14                     Pin 16



                      Other LCD Connections
                      ---------------------

                 LCD VSS    _____________    Ground
                   Pin 1                     

            LCD VDD (VCC)   _____________    + 5V        
                    Pin 2

                   LCD VD   _____________     Wiper of 10 k potentiometer 
                    Pin 3                     for setting contrast

                  LCD R/W   _____________     Ground
                    Pin 5                     

             LCD LED A (+)   _____________    via 220 ohm resistor to +5V 
                    Pin 15                    

             LCD LED K (-)   _____________    Ground
                    Pin 16                    


Further details of the hardware and the circuit diagram can be found at:
http://www.alg.myzen.co.uk/radio_g/qrp/fl50b_dds_vfo.htm


// ==============================================================================================
// Coding Standards
// ==============================================================================================

/*
My prefered coding standards document can be found at:
https://chaste.cs.ox.ac.uk/trac/raw-attachment/wiki/CodingStandardsStrategy/codingStandards.pdf



Abbreviations
-------------
Where abbreviations are included within names of variables or functions, the abbreviation will be 
transformed to title case. For example, LPF becomes Lpf

Naming of global constant
-------------------------
UPPER_CASE with underscore separators
   If associated with digital input pin: add _ip<pin number> suffix
   If associated with analogue input pin: add _ipA<pin number> suffix 
   If associated with digital output pin: add _op<pin number> suffix
   If associated with analogue output pin: add _opA<pin number> suffix

Naming of global variable
-------------------------
TitleCamelCase comprising a descriptive name or compound name

Naming of Local variable
------------------------
camelCase comprising a descriptive name or compound name

Naming of Struct
----------------
TitleCamelCase comprising a descriptive name or compound name

Naming of Function
------------------
TitleCamelCase comprising a descriptive query or action statement, possibly prefixed with 
a word indicated the purpose, such as Is/Has/Get/Set

Curly bracket
-------------
Unless the opening bracket is used to enclose data, it should be placed by itself on a new line

For Loop
---------
i retained

Clarity of code
---------------
This program avoids the use of shorthand C++ statements.  For example, 'i = i + 1', rather than 'i++'

*/

// ==============================================================================================
//  Global declarations and initialisations
// ==============================================================================================

// ----------------------------------------------------------------------------------------------
//  Libraries
// ----------------------------------------------------------------------------------------------

#include <EEPROM.h> // IDE Standard
#include <Rotary.h> // Ben Buxton https://github.com/brianlow/Rotary
#include <Wire.h>   // IDE Standard
#include <si5351.h> // Etherkit Si5331 library from NT7S,  V2.1.4   https://github.com/etherkit/Si5351Arduino

// ----------------------------------------------------------------------------------------------
//  Liquid Crystal Display
// ----------------------------------------------------------------------------------------------

#include <LiquidCrystal.h> // IDE Standard

// Initialise the LiquidCrystal library by defining the interface between the
// LCD and the Arduino Nano.
const byte LCD_RS_op8 = 8;   // LCD Register Select (Nano D8 output)
const byte LCD_E_op9 = 9;    // LCD Enable (Nano D9 output)
const byte LCD_D4_op10 = 10; // LCD D4 (Nano D10 output)
const byte LCD_D5_op11 = 11; // LCD D5 (Nano D11 output)
const byte LCD_D6_op12 = 12; // LCD D6 (Nano D12 output)
const byte LCD_D7_op13 = 13; // LCD D7 (Nano D13 output)

uint32_t _last_BandIndex = -1;
uint32_t _last_freq = -1;
// Used in RefreshLcd function to decide whether to update the display.

LiquidCrystal
    lcd(LCD_RS_op8, LCD_E_op9, LCD_D4_op10, LCD_D5_op11, LCD_D6_op12, LCD_D7_op13);

// ----------------------------------------------------------------------------------------------
//  Arduino Nano digital pin assignments
// ----------------------------------------------------------------------------------------------

//                 0       Serial communications bus
//                 1       Serial communications bus

const byte ENCODER_A_ip2 = 2; // input from encoder pin A, pin D2 pulsed low
const byte ENCODER_B_ip3 = 3; // input from encoder pin B, pin D3 pulsed low

// ----------------------------------------------------------------------------------------------
//  Arduino Nano analogue pin assignments
// ----------------------------------------------------------------------------------------------

const byte SW_SET1_ipA2 = A2;

/*
SW_SET1 is the input from Switch Set 1 which uses up to ten momemtary push button switches to select 
an associated pull down resistor to form a potential divider with a 470 ohm rersistor connected to + 5V.
The resulting voltage at A2 is read during loop() and may trigger an operation.   Only three push 
buttons are used for this project (for Band Up, Band Down, and Frequency Step Size).
*/

//    100: BAND_UP      Shifts VFO frequency up one band (3.5 > 7 > 14 > 21 > 28 MHz, then 3.5 etc.)
//    209: BAND_DOWN    Shifts VFO frequency down one band (28 > 21 > 14 > 7 > 3.5 MHz, then 28 etc.)
//    305: ENCODER_PB   Pressing the rotary encoder push button changes the tuning step size with each
//                      short press (10^4 >  10^3  > 10^2 > tens of Hz, then 10^4 etc.)
//
//
//                A3    Not used
//                A4    Used for SDA
//                A5    Used for SCL

// ----------------------------------------------------------------------------------------------
//  User preferences
// ----------------------------------------------------------------------------------------------

const int NUMBER_OF_BANDS = 5;
// The FL50B has five selectable bands

// ----------------------------------------------------------------------------------------------
//  Global variables
// ----------------------------------------------------------------------------------------------

unsigned long Txlo = 5712400; // Frequency of local oscillator in FL-50B in Hz.  The VFO frequency
                              // generated by this project needs to be shifted by <Txlo> Hz.

byte ButtonNumber; // Push button identifier

// See: https://forum.arduino.cc/t/defining-a-struct-array/43699/2

// ----------------------------------------------------------------------------------------------
// Combined Typedef and Structure declaration for band parameters.
// These parameters apply on a per band basis (Status; Frequency in Hz; Step Size)
typedef struct
{
    boolean active;
    uint32_t Hz;
    uint32_t radix;
} BandParameters;

// ----------------------------------------------------------------------------------------------
// Array of BandParameters, one set per band
BandParameters Band[NUMBER_OF_BANDS];

// ----------------------------------------------------------------------------------------------
// Variables for index into Band array
byte BandIndexCurrent;
byte BandIndexPrevious;

// ----------------------------------------------------------------------------------------------
// Initialisation of Si5351 DDS IC.  I2C address defaults to x60 in the NT7S si5351 library
Si5351 si5351;

// ----------------------------------------------------------------------------------------------
// Variables for reading the two inputs that determine rotary encoder movement and direction
Rotary r = Rotary(ENCODER_B_ip3, ENCODER_A_ip2);

bool FunctionState = false;
// if true, the next button pressed is interpreted as a special function button

// ----------------------------------------------------------------------------------------------
// Declare variables for controlling EEPROM writes
unsigned long LastFrequencyChangeTimer;
bool EepromUpdatedSinceLastFrequencyChange;
bool FrequencyChanged = false;

// ----------------------------------------------------------------------------------------------
// Interrupt Service Routine (ISR) for reading rotary encoder
ISR(PCINT2_vect)
{
    unsigned char result = r.process();
    if (result == DIR_CW)
        ChangeFrequency(1);
    else if (result == DIR_CCW)
        ChangeFrequency(-1);
}

// ==============================================================================================
//      Start of setup() function.   Runs once.  Used to initialize variables, pin modes,
//                                   start using libraries, etc..
// ==============================================================================================

void setup()
{
    // ----------------------------------------------------------------------------------------------
    // Set the serial communications data rate in bits per second (baud)
    Serial.begin(9600);

    // ----------------------------------------------------------------------------------------------
    // Initialise Wire library to connect the I2C bus
    Wire.begin();

    // ----------------------------------------------------------------------------------------------
    // Print project name to concole
    Serial.println("FL-50B VFO ");

    // ----------------------------------------------------------------------------------------------
    // Initialise LCD with device type (16 columns and 2 rows)
    lcd.begin(16, 2);

    // ----------------------------------------------------------------------------------------------
    // Display project name for 2 seconds, then clear it
    lcd.print("FL-50B VFO");
    delay(2000);
    lcd.clear();

    // ----------------------------------------------------------------------------------------------
    // Display version number (first row) and version date (second row) for 2 seconds, then clear it
    lcd.print("Build V01.05");
    lcd.setCursor(0, 1);
    lcd.print("09/12/2022");
    delay(2000);
    lcd.clear();

    // ----------------------------------------------------------------------------------------------
    // Display author details for 2 seconds, then clear it
    lcd.print("Steve Rawlings ");
    lcd.setCursor(0, 1);
    lcd.print("G4ALG ");
    delay(2000);
    lcd.clear();

    // ----------------------------------------------------------------------------------------------
    // Prepare for subsequent use of the LCD and show underscore cursor.
    lcd.cursor();

    // ----------------------------------------------------------------------------------------------
    // Set pinMode for Analogue A2 input (Switch Set 1) to pull up.
    pinMode(SW_SET1_ipA2, INPUT_PULLUP);

    // ----------------------------------------------------------------------------------------------
    // Initialise Pin Change Interrupt Control Register for rotary encoder
    PCICR |= (1 << PCIE2);
    PCMSK2 |= (1 << PCINT18) | (1 << PCINT19);
    sei();

    // ----------------------------------------------------------------------------------------------
    // Load Band array from EEPROM
    BandIndexCurrent = EEPROM.read(0);
    Serial.print("setup() eeprom: BandIndex=");
    Serial.println(BandIndexCurrent);

    // ----------------------------------------------------------------------------------------------
    // Allow for an (unlikely) reduction in NUMBER_OF_BANDS since last EEPROM update
    if (BandIndexCurrent >= NUMBER_OF_BANDS)
        BandIndexCurrent = 1;
    BandIndexPrevious = BandIndexCurrent;

    int element_len = sizeof(BandParameters);
    for (int i = 0; i < NUMBER_OF_BANDS;)
    {
        EEPROM.get(1 + (i * element_len), Band[i]);
        i = i + 1;
    };

    // ----------------------------------------------------------------------------------------------
    // Initialise and start the si5351 clocks.  Assumes the use of the default 25 MHz quartz crystal
    si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, 153125);
    si5351.set_pll(SI5351_PLL_FIXED, SI5351_PLLA);

    // ----------------------------------------------------------------------------------------------
    // Print current transmit frequency to console
    Serial.print("Tx Frequency = ");
    Serial.println(Band[BandIndexCurrent].Hz);

    // ----------------------------------------------------------------------------------------------
    // Declare variable for actual frequency to be generated for a selected transmit frequency
    volatile uint32_t f;

    // ----------------------------------------------------------------------------------------------
    // Algorithm for determining actual VFO frequency to be generated for the transmit
    // frequency currently displayed on the LCD
    {
        if ((Band[BandIndexCurrent].Hz) >= 10000000)
            f = Band[BandIndexCurrent].Hz - 5172400;

        else
            f = Band[BandIndexCurrent].Hz + 5172400;
    }

    // ----------------------------------------------------------------------------------------------
    // Initialise Si5351 frequency and output channel ('clock')
    si5351.set_freq(f * SI5351_FREQ_MULT, SI5351_CLK0);

    // ----------------------------------------------------------------------------------------------
    // Turn on the required output channel (CLK0)
    si5351.output_enable(SI5351_CLK0, 1);

    // ----------------------------------------------------------------------------------------------
    // Initialise variables relating to frequency change events
    FrequencyChanged = true;
    LastFrequencyChangeTimer = millis();
    EepromUpdatedSinceLastFrequencyChange = false;
}

// ---------------------------------------------------------------------------------------------
// End of setup() function
// ---------------------------------------------------------------------------------------------

// ==============================================================================================
//  Start of loop() function.    This function loops repeatedly.
// ==============================================================================================

void loop()
{
    UpdateEeprom();
    RefreshLcd();

    // Update the display if the frequency has been changed (and we are not
    // transmitting)
    // if (!TxState && FrequencyChanged)                //  'and' changed to &&
    // what is the and operator doing????
    {
        volatile uint32_t f;

        {
            if ((Band[BandIndexCurrent].Hz) >= 10000000)
                f = Band[BandIndexCurrent].Hz - 5172400;

            else
                f = Band[BandIndexCurrent].Hz + 5172400;
        }

        si5351.set_freq(f * SI5351_FREQ_MULT, SI5351_CLK0);

        FrequencyChanged = false;
        LastFrequencyChangeTimer = millis();
        EepromUpdatedSinceLastFrequencyChange = false;
    } // endif FrequencyChanged

    //------------------------------------------------------------------------
    // if any of the buttons have been pressed...
    bool ButtonHeld = false;
    unsigned long ButtonPressedDuration = millis();

    ButtonNumber = GetSwSet1ButtonNumber();

    while (ButtonNumber > 0 && GetSwSet1ButtonNumber() > 0)
    {
        delay(5);
        // one of the multiplexed switches is being held down - wait!
    }

    // if one of the buttons was pressed (and is now released) act on it...

    if (ButtonNumber == 1)
    {
        if (!FunctionState)
        {
            Serial.println("<B1>BAND DOWN");
            if (BandIndexCurrent == 0)
            {
                BandIndexCurrent = (NUMBER_OF_BANDS - 1);
            }
            else
            {
                BandIndexCurrent = BandIndexCurrent - 1;
            }
        }
        else
        {
            Serial.println("<F><B1>N/A");
            FunctionState = false;
        };
        FrequencyChanged = true;
    };

    if (ButtonNumber == 2)
    {
        // Button 2:
    };

    if (ButtonNumber == 3)
    {
    };

    if (ButtonNumber == 4)
    {
        if (!FunctionState)
        {
            if (ButtonHeld)
            {
                Serial.println("<B4>held-Tune");
                ButtonHeld = false;
            }
            else
            {
                Serial.println("<B4>BAND UP");
                //               Serial.print("B4 BandIndex="); Serial.print(BandIndex);
                //               Serial.print(" VFO=");
                //               Serial.println(Band[BandIndex].Hz);
                int BandIndexPrevious = BandIndexCurrent;
                if (BandIndexCurrent == (NUMBER_OF_BANDS - 1))
                    BandIndexCurrent = 0;
                else
                    BandIndexCurrent = BandIndexCurrent + 1;

                //               Serial.print("Aft BandIndex=");
                //               Serial.print(BandIndex); Serial.print(" VFO=");
                //               Serial.println(Band[BandIndex].Hz);
            }
        }
        else
        {

            lcd.clear();

            FunctionState = false;
        }
        FrequencyChanged = true;
    }

    if (ButtonNumber == 5)
    {
        Serial.println("<B5>Fn tgl");
        FunctionState = !FunctionState;
        if (FunctionState)
            Serial.println("Function...");
        FrequencyChanged = true;
    }

    if (ButtonNumber == 6)
    // Button 6: change frequency step up

    {
        if (!FunctionState)
            Serial.println("<B6>FREQUENCY STEP SIZE DOWN");
        else
            Serial.println("<F><B6>f step l");

        if (ButtonHeld)
        {
            Serial.println("<B6>held -- toggle IF filters");
        }
        else
        {

#if defined(SP_V) or defined(SP_6) or defined(SP_8) or defined(SP_9) or \
    defined(SP_11)
            switch (Band[BandIndex].radix)
            {
            case 10: {
                Band[BandIndex].radix = 100;
            }
            break;

    #ifdef SP_11
            case 100: {
                Band[BandIndex].radix = 10;
            }
            break;

    #else

            case 100: {
                Band[BandIndex].radix = 1000;
                // clear residual < 1kHz frequency component from the active VFO
                //  uint16_t f = Band[BandIndex].Hz % 1000;
                //  Band[BandIndex].Hz =  Band[BandIndex].Hz - f;
            }
            break;
    #endif

            case 1000: {
                Band[BandIndex].radix = 100;
            }
            break;

            case 10000: {
                Band[BandIndex].radix = 1000;
            }
            break;
            }
#else
            // default radix increment/decrement behaviour...
            switch (Band[BandIndexCurrent].radix)
            {
            case 10: {
                if (!FunctionState)
                {
                    // change radix up
                    Band[BandIndexCurrent].radix = 10000;
                    // clear residual < 1kHz frequency component from the active VFO
                    //  uint16_t f = Band[BandIndex].Hz % 1000;
                    //  Band[BandIndex].Hz = Band[BandIndex].Hz - f;
                }
                else
                {
                    FunctionState = false;
                    // change radix down
                    Band[BandIndexCurrent].radix = 100;
                    // clear residual < 100Hz frequency component from the active VFO
                    //  uint16_t f = Band[BandIndex].Hz % 100;
                    //  Band[BandIndex].Hz =  Band[BandIndex].Hz  - f;
                }
            }
            break;

            case 100: {
                if (!FunctionState)
                {
                    Band[BandIndexCurrent].radix = 10;
                }
                else
                {
                    FunctionState = false;
                    Band[BandIndexCurrent].radix = 1000;
                    // clear residual < 1 kHz frequency component from the active VFO
                    //  uint16_t f = Band[BandIndex].Hz % 1000;
                    //  Band[BandIndex].Hz = Band[BandIndex].Hz - f;
                }
            }
            break;

            case 1000: {
                if (!FunctionState)
                {
                    Band[BandIndexCurrent].radix = 100;
                }
                else
                {
                    FunctionState = false;
                    Band[BandIndexCurrent].radix = 10000;
                }
                break;
            }

            case 10000: {
                if (!FunctionState)
                {
                    Band[BandIndexCurrent].radix = 1000;
                }
                else
                {
                    FunctionState = false;
                    Band[BandIndexCurrent].radix = 10;
                }
                break;
            }
            }
#endif
        } // else
        FrequencyChanged = true;
    }
}

// ------------------------------------------------------------------------------------------------------------------
// Functions
// ------------------------------------------------------------------------------------------------------------------

//**************************************/
//* Change frequency
//**************************************/

void ChangeFrequency(int dir)
{

    if (dir == 1) // Increment
    {
        Band[BandIndexCurrent].Hz =
            Band[BandIndexCurrent].Hz + Band[BandIndexCurrent].radix;
    }
    else
    {
        if (dir == -1) // Decrement

            Band[BandIndexCurrent].Hz =
                Band[BandIndexCurrent].Hz - Band[BandIndexCurrent].radix;
    };

    FrequencyChanged = 1;
};

/**
 * Take a reading of the front panel buttons and map it to a button number.
 * Requiring three consecutive identical readings before accepting the result.
*/
byte GetSwSet1ButtonNumber()
{
    byte numberOfConsecutiveButtonResultsRequired = 20;
    byte numberOfConsecutiveButtonResults = 0;
    byte previousButtonNumber = -1;

    while (numberOfConsecutiveButtonResults < numberOfConsecutiveButtonResultsRequired)
    {
        int currentButtonNumber = GetSwSet1ButtonNumberAtInstant();

        if (currentButtonNumber == previousButtonNumber)
        {
            numberOfConsecutiveButtonResults = numberOfConsecutiveButtonResults + 1;
        }
        else
        {
            previousButtonNumber = currentButtonNumber;
        }
    }

    if (previousButtonNumber > 0)
    {
        Serial.print(" [Front button - ");
        Serial.print(previousButtonNumber);
        Serial.println("]");
    }

    return previousButtonNumber;
} // GetSwSet1ButtonNumber()

byte GetSwSet1ButtonNumberAtInstant()
// Take a reading of the front panel buttons and map it to a button number
// (0..4)
{
    byte b = 0;
    int z;
    z = ReadAnalogPin((byte)SW_SET1_ipA2);
    //  Serial.print("Frnt bttn="); Serial.println(z);

    if (z > 59 && z < 141)
        b = 4; // 100  band up
    else if (z > 168 && z <= 249)
        b = 1; // 209  band down
    else if (z > 254 && z <= 345)
        b = 6; // 305  radix
               // else if (z >= 0 && z <= 40)   b = ?;  //   0  net switch

    if (b > 0)
    {
        Serial.print(z);
        Serial.print(" : ");
    }
    return b;
} // GetSwSet1ButtonNumberAtInstant()

int ReadAnalogPin(byte p)
{
    // Take an averaged reading of analogue pin 'p'
    int i,
        val = 0,
        nbr_reads = 1; //  this used to average 2 readings!  Resulted in failure
                       //  to identify the correct button due to averaging of
                       //  voltage levels under contact bounce scenarios, hence
                       //  decoding to the wrong button number!
    for (i = 0; i < nbr_reads;)
    {
        val = val + analogRead(p);
        delay(1);
        i = i + 1;
    }
    return val / nbr_reads;
};

byte ReadSwitchSet2()
{
    // Reads the keyer memory buttons (switch set 2) and returns the button
    // nuSwitchSet2Buttoner as a byte; 0 if not pressed
    byte SwitchSet2Button = 0;
    int voltageLevel;
    //    voltageLevel = ReadAnalogPin(SW_SET2_ipA3);    // read the analog pin

    // Serial.print("Kyr pshbtn voltageLevel="); Serial.println(voltageLevel);

    // Voltage level (0-1023) to button look-up

    if (voltageLevel > 471 && voltageLevel < 551)
        SwitchSet2Button = 1; //  MEM1
    if (voltageLevel > 594 && voltageLevel < 674)
        SwitchSet2Button = 2; //  MEM2
    if (voltageLevel > 676 && voltageLevel < 756)
        SwitchSet2Button = 3; //  MEM3
    if (voltageLevel > 770 && voltageLevel < 850)
        SwitchSet2Button = 4; //  MEM4

    if (SwitchSet2Button > 0)
    {
        Serial.print("Keyer pushbutton=");
        Serial.print(SwitchSet2Button);
        Serial.print(", voltageLevel=");
        Serial.println(voltageLevel);
    }
    return SwitchSet2Button;
}

/*

void RxTxControl(char c)
{
    // if necessary, activates the receiver or the transmitter
    // 'c' may be either 'T' or 'R'
    // and, in the future, 'N' (Net) to indicate low level TX carrier 'on' while
    // receiver running.

    //  if(!TxState && c =='T') ChangeStateRxToTx();
    //  else
    //    if(TxState && c =='R') ChangeStateTxToRx();
    // else
    //  //  if(!TxState &&  c =='N')  receive_to_NET();

    // in  all other cases, do nothing!
}

*/

/*

Scratch Pad Area to learn about Classes.

This learning exercise is aimed at creating a Class and an Object to refresh the
LCD such that the current Function 'RefreshLcd' is replaced through an
object-oriented approach.



// clang-format: off
class Display {             // Create the Display class.  Here, display is a
noun. public:               // 'public' specifies that access to
attributes and
                            // methods are
                            // accessible from outside the class.


  Display()                // Create the Display public method.  Here, Display
is a verb.


  // assign the following values to the attribute 'lcd' within the LiquidCrystal
class
  // where LiquidCrystal is private to
  : lcd(LCD_RS_op8, LCD_E_op9, LCD_D4_op10, LCD_D5_op11, LCD_D6_op12,
LCD_D7_op13)
  , _text_changed{true}
  , _text("")
  { lcd.begin(16, 2);  }

  void Refresh()
  {

    if (!_text_changed)
      return;

    lcd.setCursor(0, 1);
    lcd.print(_text);

    _text_changed = false;
  }

  bool SetText(String text) {
    if (text.length() > 16) {
      return false;
    }

    _text = text;
    _text_changed = true;

    return true;
  }

private:
  String _text;
  bool _text_changed;
  LiquidCrystal lcd;
};

Display display;     //Create the display object of Display

void setup() {
  // set up the LCD's number of columns and rows:
  // lcd.begin(16, 2);
  // // Print a message to the LCD.
  // lcd.print("hello, world!");
}

void loop() {
  //
  auto new_text = String(millis() / 1000);

  auto ok = display.SetText(new_text);
  if (!ok) {
    // Serial.println(String("[Error] invalid text: ") + new_text);
  }

  display.Refresh();
}

*/

void RefreshLcd()
{
    // Update the LCD
    uint16_t f, g;
    uint32_t band_l;
    band_l = Band[BandIndexCurrent].Hz;

    // Check whether BandIndex has changed.  If so, set the cursor position and
    // update LCD with wavelength.

    if (BandIndexCurrent != _last_BandIndex)
    {
        lcd.setCursor(0, 0);

        if (BandIndexCurrent == 0)
        {
            lcd.print("80m");
        }
        else if (BandIndexCurrent == 1)
        {
            lcd.print("40m");
        }
        else if (BandIndexCurrent == 2)
        {
            lcd.print("20m");
        }
        else if (BandIndexCurrent == 3)
        {
            lcd.print("15m");
        }
        else if (BandIndexCurrent == 4)
        {
            lcd.print("10m");
        }
        lcd.print("  ");
        lcd.print(" ");
    }

    // Check whether BandIndex has changed.
    // If so, set the cursor and update LCD with FL-50B PA Loading and Grid crib
    // details for the band.

    if (BandIndexCurrent != _last_BandIndex)
    {
        lcd.setCursor(0, 1);

        if (BandIndexCurrent == 0) // 80m
        {
            lcd.print("LDG:5.0 GRID:2.3");
        }
        else if (BandIndexCurrent == 1) // 40m
        {
            lcd.print("LDG:7.5 GRID:1.5");
        }
        else if (BandIndexCurrent == 2) // 20m
        {
            lcd.print("LDG:4.2 GRID:6.2");
        }
        else if (BandIndexCurrent == 3) // 15m
        {
            lcd.print("LDG:4.6 GRID:4.3");
        }
        else if (BandIndexCurrent == 4) //10m
        {
            lcd.print("LDG:5.4 GRID:2.5");
        }
    }

    if (BandIndexCurrent != _last_BandIndex)
    {
        _last_BandIndex = BandIndexCurrent;
    }

    // Check whether frequency has changed.
    // If so, set the cursor position and update LCD with new frequency.

    if (band_l != _last_freq)
    {

        lcd.setCursor(6, 0);

        f = band_l / 1000000;
        if (f < 10)
            lcd.print(' ');
        lcd.print(f);
        lcd.print('.');

        f = (band_l % 1000000) / 1000;
        if (f < 100)
            lcd.print('0');
        if (f < 10)
            lcd.print('0');
        lcd.print(f);
        lcd.print('.');

        f = band_l % 1000;
        if (f < 100)
            lcd.print('0');
        if (f < 10)
            lcd.print('0');
        lcd.print(f);
        lcd.print(" ");
    }

    if (band_l != _last_freq)
    {
        _last_freq = band_l;
    }

    byte CursorPosition = 14;

    switch (Band[BandIndexCurrent].radix)
    {
    case 10:
        lcd.setCursor(CursorPosition, 0);
        break;

    case 100:
        lcd.setCursor(CursorPosition - 1, 0);
        break;

    case 1000:
        lcd.setCursor(CursorPosition - 3, 0);
        break;

    case 10000:
        lcd.setCursor(CursorPosition - 4, 0);
        break;
    };
}

// ------------------------------------------------------------------------------------------------------------------
// EEPROM

void UpdateEeprom()
{
    if (abs(millis() - LastFrequencyChangeTimer) > 10000)
    {
        if (EepromUpdatedSinceLastFrequencyChange == false)
        {
            // do the eeprom write
            // Serial.println("*** eeprom write");
            EEPROM.write(
                0, BandIndexCurrent); // write the band index (BandIndex) to the first byte

            int element_len = sizeof(BandParameters);
            for (int i = 0;
                 i < NUMBER_OF_BANDS;) // write each element of the Band array
            {
                EEPROM.put(1 + (i * element_len), Band[i]);
                i = i + 1;
            }
            EepromUpdatedSinceLastFrequencyChange = true;
        }
    }
};
